# gh-actions-demo

GitHub actions will soon become a major player on the CI SaaS market, as far as I can tell GitHub actions can easily replace 
most CI tools out there especially if you ship code as container images. 
With GitHub actions you can do more then CI/CD, most tasks performed today with 
bots (code sign validations, issue management, notifications, etc) can be made into workflows and run solely by GitHub.

Why would you give up on your current CI SaaS and self hosted bots for GitHub actions? 
For once GitHub actions simplifies automation by offering a serverless platform capable of handling most development tasks, as a
developer you don't have to jump from one SaaS to another to diagnose some build error. 
The less environments you have to use on a regular bases the better it gets and as a developer you probably spend most of your time on GitHub anyway.

### The anatomy of a GitHub action

In many ways GitHub actions are similar to FaaS, as with functions a GitHub action can be triggered by an 
event and you can chain multiple actions to create a workflow that defines how you want to react to that particular event.

Most FaaS solutions made for Kubernetes let you package a function as a container image, 
a Github action is no more then that, a piece of code packaged as a container image that GitHub will run for you. 

In order to make a GitHub action all you need to do is to create a Dockerfile. Here is an example of a GitHub action 
that runs unit tests for a golang project:

```bash
FROM golang:1.10

LABEL "name"="go test action"
LABEL "maintainer"="Stefan Prodan <support@weave.works>"
LABEL "version"="1.0.0"

LABEL "com.github.actions.icon"="code"
LABEL "com.github.actions.color"="green-dark"
LABEL "com.github.actions.name"="gotest"
LABEL "com.github.actions.description"="This is an action to run go test."

COPY entrypoint.sh /entrypoint.sh
ENTRYPOINT ["/entrypoint.sh"]
```
And the container entry point script that runs the tests:

```bash
#!/usr/bin/env bash

set -e +o pipefail

APP_DIR="/go/src/github.com/${GITHUB_REPOSITORY}/"

mkdir -p ${APP_DIR} && cp -r ./ ${APP_DIR} && cd ${APP_DIR}

go test $(go list ./... | grep -v /vendor/) -race -coverprofile=coverage.txt -covermode=atomic
mv coverage.txt ${GITHUB_WORKSPACE}/coverage.txt
```

If the tests pass, the coverage report is copied to the GitHub workspace. The workspace is shared between all the actions 
part of the same workflow, that means that you can use the coverage report generated by the go test action in another action that 
could publish the report to codecov.

This is how you can define a workflow that will publish the test coverage after a git push:

```hcl
workflow "Publish test coverage" {
  on = "push"
  resolves = ["Publish coverage"]
}

action "Run tests" {
  uses = "./.github/actions/gotest"
}

action "Publish coverage" {
  needs = ["Run tests"]
  uses = "./.github/actions/codecov"
  args = "-f ${GITHUB_WORKSPACE}/coverage.txt"
}
```

Th above workflow uses actions defined in the same repository as the app code but you can also define GitHub actions in a 
dedicated repo, for example instead of `./.github/actions/gotest` it could be `stefanprodan/gh-actions/gotest@master` or a even 
a container image hosted on Docker Hub `docker://stefanprodan/gotest:latest`. Running each workflow step in a container is not a novelty,
Jenkins docker pipelines, Drone, GCP builder and other tools are doing the same thing but what I like about GitHub actions is that you 
don't need to build and publish the action container image to a registry. 
Github lets you reference a git repo where your action Dockerfile is and it will build the container image before running the workflow. 

### Building a GitOps pipeline for Kubernetes

GitOps has a different approach on how you define and deploy your workloads. 

In the GitOps model the state of your Kubernetes cluster(s) is kept in a dedicated git repo (I will refer to this as the config repository). 
That means the app deployments, Helm releases, network polices and any other Kubernetes custom resource are 
managed from a single repo that defines your cluster desired state.

If you look at the [GKE CI/CD example](https://github.com/actions/example-gcloud/blob/master/.github/main.workflow#L76) made by GitHub,
the deployment file is the same repo with the app code and the Docker image tag is being injected from an environment variable. 
This works fine until you run into a cluster melt down or you need to rollback a deployment to a previous version. 
In case of a major incident you have to rerun the last deployment workflow (in every app repo) but that doesn't mean you will end up with the 
same state as it was before since you'll be building and deploying new images.

GitOps solves this problem by reapplying the config repo every time the cluster diverges from the state defined in git. 
For this to work you'll need a GitOps operator that runs in your cluster and a container registry 
where GitHub actions are publishing immutable images (no latest tags, use semantic versioning or git sha).

I will be using [podinfo](https://github.com/stefanprodan/k8s-podinfo) to demonstrate a GitOps pipeline including promoting releases between environments.

I'm assuming the following Git branching model:

* dev branch (feature-ready state)
* master branch (production-ready state)

When commits are pushed in the dev branch, a GitHub workflow will kick in and produce a immutable container image as in `repo/app:branch-commitsha`.

This how a workflow could look for a golang app:

<img src="https://raw.githubusercontent.com/stefanprodan/gh-actions-demo/master/docs/screens/github-actions-podinfo.png" height="500">

The build action will tag the container image with the git branch-sha or with the git tag if you make a GitHub release.
The GitHub actions used in this workflow can be found [here](https://github.com/stefanprodan/gh-actions-demo/tree/master/.github).

```hcl
workflow "Publish container" {
  on = "push"
  resolves = ["Push"]
}

action "Lint" {
  uses = "./.github/actions/golang"
  args = "fmt"
}

action "Test" {
  needs = ["Lint"]
  uses = "./.github/actions/golang"
  args = "test"
}

action "Build" {
  needs = ["Test"]
  uses = "./.github/actions/docker"
  secrets = ["DOCKER_IMAGE"]
  args = ["build", "Dockerfile"]
}

action "Login" {
  needs = ["Build"]
  uses = "actions/docker/login@master"
  secrets = ["DOCKER_USERNAME", "DOCKER_PASSWORD"]
}

action "Push" {
  needs = ["Login"]
  uses = "./.github/actions/docker"
  secrets = ["DOCKER_IMAGE"]
  args = "push"
}
```

If you have access to GitHub Action you can create a private repository named `demo-app` and navigate to Settings/Secrets and add the following secrets:

* `DOCKER_IMAGE` eg stefanprodan/demo-app
* `DOCKER_USERNAME` eg stefanprodan
* `DOCKER_PASSWORD` eg my-docker-hub-pass

Install podinfo CLI:

```bash
brew install weaveworks/tap/podcli
```

For linux or Windows go to the 
[release page](https://github.com/stefanprodan/k8s-podinfo/releases), download the latest podcli release and add it to your path.

Clone your private repository (preferable in your `$GOPATH`) and initialize podinfo.

```bash
git clone https://github.com/stefanprodan/demo-app
cd demo-app

podcli code init demo-app --git-user=stefanprodan --version=master
```

The above command does the following:
* downloads podinfo source code master branch
* replaces golang imports with your git username and project name
* creates a Dockerfile and Makefile customized for GitHub actions
* creates the main workflow for GitHub actions
* commits and pushes the code to GitHub

When the code init command finishes, GitHub will test, build and push a Docker image 
`${DOCKER_IMAGE}:${GIT-BRANCH}-${GIT-SHORT-SHA}` to your Docker Hub account.

If you create a GitHub release a Docker image with the format `${DOCKER_IMAGE}:${GIT-TAG}` will be published to Docker Hub.





 












