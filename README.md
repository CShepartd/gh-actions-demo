# gh-actions-demo

GitHub actions will soon become a major player on the CI SaaS market, as far as I can tell GitHub actions can easily replace 
most CI tools out there especially if you ship code as container images. 
With GitHub actions you can do more then CI, most tasks performed today with 
bots (code sign validations, issue management, notifications, etc) can be made into workflows and run solely by GitHub.

### The anatomy of a GitHub action

In many ways GitHub actions are similar to FaaS and serverless, as with functions a GitHub action can be triggered by an 
event and you can chain multiple actions to create a workflow that defines how you want to react to that particular event.

Most FaaS solutions made for Kubernetes let you package a function as a container image, 
a Github action is no more then that, a piece of code packaged as a container image that GitHub will run for you. 

In order to make a GitHub action all you need to do is to create a Dockerfile. Here is an example of a GitHub action 
that runs unit tests for a golang project:

```bash
FROM golang:1.10

LABEL "name"="go test action"
LABEL "maintainer"="Stefan Prodan <support@weave.works>"
LABEL "version"="1.0.0"

LABEL "com.github.actions.icon"="code"
LABEL "com.github.actions.color"="green-dark"
LABEL "com.github.actions.name"="gotest"
LABEL "com.github.actions.description"="This is an action to run go test."

COPY entrypoint.sh /entrypoint.sh
ENTRYPOINT ["/entrypoint.sh"]
```
And the container entry point script that runs the tests:

```bash
#!/usr/bin/env bash

set -e +o pipefail

APP_DIR="/go/src/github.com/${GITHUB_REPOSITORY}/"

mkdir -p ${APP_DIR} && cp -r ./ ${APP_DIR} && cd ${APP_DIR}

go test $(go list ./... | grep -v /vendor/) -race -coverprofile=coverage.txt -covermode=atomic
mv coverage.txt ${GITHUB_WORKSPACE}/coverage.txt
```

If the tests pass the coverage report is copied to the GitHub workspace. The workspace is shared between all the actions 
part of the same workflow, that means that you can use the coverage report generated by the go test action in another action that 
could publish the report to codecov.

This is how you can define a workflow that will publish the test coverage after a git push:

```hcl
workflow "Publish test coverage" {
  on = "push"
  resolves = ["Publish coverage"]
}

action "Run tests" {
  uses = "./.github/actions/gotest"
}

action "Publish coverage" {
  needs = ["Run tests"]
  uses = "./.github/actions/codecov"
  args = "-f ${GITHUB_WORKSPACE}/coverage.txt"
}
```

Th above workflow uses actions defined in the same repository as the app code but you can also define GitHub actions in a 
dedicated repo, for example instead of `./.github/actions/gotest` it could be `stefanprodan/gh-actions/gotest@master` or a even 
a container image hosted on Docker Hub `docker://stefanprodan/gotest:latest`. Running each workflow step in a container is not a novelty,
Jenkins docker pipelines, Drone, GCP builder and other tools are doing the same thing but what I like about GitHub actions is that you 
don't need to build and publish the action container image to a registry. 
Github lets you reference a git repo where your action Dockerfile is and it will build the container image before running the workflow. 








